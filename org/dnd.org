#+title:     Dungeons & Dragons
#+author:    Logan Barnett
#+email:     logustus@gmail.com
#+date:      <2019-09-15 Sun>
#+language:  en
#+file_tags:
#+tags:

* tracking the current round
  I frequently lose track of which round it is as I apply effects between
  creatures that exist in the initiative order. Having a stark visual counter
  that I advance with a key binding would be just dandy.

  Combat tables will be expressed with the following format:

  | turn | name | ord | ac | chp | thp | hit | dmg | spec | dist |
  |------+------+-----+----+-----+-----+-----+-----+------+------|

  The =turn= column should indicate the current turn with a series of glyphs
  such as =>>>>= or similar, and I can at some point make it work with a font
  face.
** turn hook
   We can fire an event when we arrive at a turn, and provide information about
   whose turn it is.

   #+begin_src emacs-lisp :results none
     (defvar dnd/turn-functions '()
       "A hook for arriving upon a turn. Provides a ROW."
       )
   #+end_src

** indicator
*** format
   The indicator will be =>>>>= but I should be able to change it.

   #+begin_src emacs-lisp :results none
     (defcustom dnd/turn-indicator-string ">>>>" "String to use for the current turn.")
   #+end_src

*** setting
    Setting the indicator will populate the cell with
    =dnd/turn-indicator-string=.

    #+begin_src emacs-lisp :results none
      (defun dnd//set-turn (row)
        (org-table-put row 1 dnd/turn-indicator-string t)
        (org-table-goto-line row)
        ;; It would be nice to send the row data, but alas.
        (run-hook-with-args 'dnd/turn-functions row)
        )
    #+end_src

** get table lines

   #+begin_src emacs-lisp :results none

     (defun dnd//get-table-lines ()
       (let* (
              (beg (org-table-begin))
              (end (copy-marker (org-table-end)))
              )
         (- (length (split-string
                     (filter-buffer-substring beg end)
                     "\n"
                     t
                     )
                    )
            3))
       )

   #+end_src

** find turn indicator
   The turn indicator will be =>>>>= on the =turn= column. We should go to the
   column and then walk down it until we find it. If we don't find it, return
   =nil=.

   #+begin_src emacs-lisp :results none
     (defun dnd//walk-column-for-indicator (lines line)
       (message "value %s" (org-table-get (+ 2 line) 1))
       (if (< line (+ 1 lines))
           (if (string-equal (org-table-get (+ 2 line) 1) dnd/turn-indicator-string)
               line
             (dnd//walk-column-for-indicator lines (+ 1 line))
             )
         nil
         )
       )

     (defun dnd//add-indicator (line)
       (org-table-put line 1 dnd/turn-indicator-string)
       2
       )


     (defun dnd/find-turn-indicator ()
       (if (org-at-table-p)
           (let* (
                  (lines (dnd//get-table-lines))
                  (indicator (dnd//walk-column-for-indicator lines 0))
                  )
             (message "indicator? %s" indicator)
             (if indicator (+ 2 indicator) nil)
             )
         nil
         )
       )
   #+end_src

** next round

   #+begin_src emacs-lisp :results none

     (defun dnd/next-round ()
       (interactive)
       (if (org-at-table-p)
           (let* (
                  (indicator (dnd/find-turn-indicator))
                  (next (+ (or indicator 0) 1))
                  (lines (dnd//get-table-lines))
                  )
             (if indicator
                 (progn
                   (org-table-put indicator 1 "" t)

                   (if (< next (+ 3 lines))
                       (progn
                         (dnd//set-turn next)
                         )
                     (progn
                       (dnd//set-turn 2)
                       )
                     )
                   )
               (progn

                 (dnd//set-turn 2)
                 )
               )
             )
         (message "Not on a table!")
         )
       )

   #+end_src

** key binding
   =dnd/next-round= is a function for tables, in =org-mode=, so it might be
   reasonable to place this table operation in the =, t= prefix, but I suspect a
   suite of D&D bindings may be on the way. =, D= is available.

   #+begin_src emacs-lisp :results none
     (spacemacs/declare-prefix-for-mode 'org-mode "mD" "dnd" "dnd")
     (spacemacs/set-leader-keys-for-major-mode 'org-mode (kbd "D n") 'dnd/next-round)
   #+end_src

* snap to monster profile
  When a monster takes its turn, I'd love to know what that monster has for
  capabilities, notes I might have on that monster (or its kind), and other
  aspects of it. This is hard to efficiently encode in the combat table. When
  using =dnd-next-round= the profile should pop up in a vertical split window.

** where to look
   I keep all of my files in =dnd5e.org=. Maybe there's a better place for it,
   but for now let's put it there.

   #+begin_src emacs-lisp :results none
     (defvar dnd/profile-path (expand-file-name "~/Dropbox/notes/dnd5e.org"))
   #+end_src

** get kind
   There needs to be a =kind= column in the combat table. This is the name we
   will key off of.

   #+begin_src emacs-lisp :results none
    (defvar dnd/kind-column 3)
   #+end_src


** open profile

   Once we land on a monster row and have a kind, we can find its profile.

   #+begin_src emacs-lisp :results none
      (defun dnd//open-profile (row)
        (let ((kind (org-table-get row dnd/kind-column)))
          (if (string-empty-p kind)
              nil
              (progn
                (org-link-open-from-string
                 (format "[[file:%s::*%s][%s]]"
                         dnd/profile-path
                         kind
                         kind
                         ))
                (org-show-entry)
                (select-window (previous-window))
                )
            )
          ;; (org-mark-ring-goto)
          )
        )
   #+end_src

** listen for turns
   We need to listen for turn changes, and we can do this using
   =dnd/turn-functions= (not =-hook= because it is "abnormal" in that it must
   pass an argument).

   #+begin_src emacs-lisp :results none
     (add-hook 'dnd/turn-functions #'dnd//open-profile)
   #+end_src
